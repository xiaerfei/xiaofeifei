---
title: L4 Python 建模操作系统
tags: 操作系统
Mermaid: true
Mathjax: true
---
## 状态机
提出了大胆的想法：`无论是软件还是硬件，都是状态机`{:.info}
`而状态和状态的迁移是可以 “画” 出来的！` 理论上说，只需要两个 API:

- dump_state() - 获取当前程序状态
- single_step() - 执行一步

由此可以简化操作系统: `把复杂的东西分解成简单的东西`，我们真正关心的概念：

- 应用程序 (高级语言状态机)
- 系统调用 (操作系统 API)
- 操作系统内部实现

没有人规定上面三者如何实现，通常的思路：`真实的操作系统 + QEMU/NEMU 模拟器`

我们的思路:

- 应用程序 = 纯粹计算的 Python 代码 + 系统调用
- 操作系统 = Python 系统调用实现，有 “假想” 的 I/O 设备

```py
def main():
    sys_write('Hello, OS World')
```
## 玩具的意义
并没有脱离真实的操作系统
- “简化” 了操作系统的 API
    - 在暂时不要过度关注细节的时候理解操作系统
- 细节也会有的，但不是现在
    - 学习路线：先 100% 理解玩具，再理解真实系统和玩具的差异

比如用 C 实现如下：

```c
void sys_write(const char *s) { printf("%s", s); }
void sys_sched() { usleep(rand() % 10000); }
int sys_choose(int x) { return rand() % x; }

void sys_spawn(void *(*fn)(void *), void *args) {
    pthread_create(&threads[nthreads++], NULL, fn, args);
}
```

## 参考

[4. Python 建模操作系统](https://jyywiki.cn/OS/2023/build/lect4.ipynb)